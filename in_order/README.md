# 实验三 ——三种排序

## 需求分析

输入一列数，编程实现直接插入排序，快速排序，简单选择排序三类算法。

要求：给出每一次排序过程的中间过程

## 概要设计

将三种算法分别以三个函数实现，在主函数中根据用户的选择来决定实际采用哪种方法实现排序，并调用相关函数。

## 详细设计

* 主函数

提示用户输入数的个数（count），具体有哪些数（用数组num[]存储），以及选择哪种方法；根据选用的方法，调用相应函数（SInsert()，QSort()或SSort()），最后，打印出最终排序结果。

* SInsert()直接插入排序函数

传入参数为数组num[],和长度count；没有返回值。

默认输入的是一组完全乱序的数，因此将第一个数默认为起始的有序组合，然后在紧接着有序组合外的一个数并入有序组合，不断向前移动直到其大于前一项。如此循环count-1次后，就得到了排列为从小到大一组的数。

* QSort()快速排序函数

传入参数为数组num[],起始标号（整型变量）start，终末标号（整型变量）end；返回值为int类

调用函数后，以有效范围内起始的第一个数为枢纽（key），利用low和high完成大于key和小于key两部分位置的交换，最终形成枢纽key左侧均比其小，右侧均比其大的一组数，然后再调用QSort()完成左右侧的递归（满足存在乱序的可能），最终得到排列为从小到大一组的数。

* SSort()简单选择排序函数

传入参数为数组num[],和长度count；没有返回值。

调用函数后，注意比较num[temp]与每个数大小，使得num[temp]一直处于最小将每轮扫描比较得到的最小数放在扫描起始处的最前面，下一次扫描则在其后开始。如此完成count次循环扫描后，得到了排列为从小到大一组的数。

## 调试分析

在设计QSort()时，在对剩余部分进行递归时，误用了return，（即return QSort(……)）导致每次排序只完成了一部分。后来，在跟踪调试的时候，才发现每次只完成了一半的快速排序。移除后，程序正常运行。
